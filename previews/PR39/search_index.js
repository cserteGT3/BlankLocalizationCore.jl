var documenterSearchIndex = {"docs":
[{"location":"api/#Using-the-API-to-extend-the-geometry-types","page":"API extension","title":"Using the API to extend the geometry types","text":"","category":"section"},{"location":"api/","page":"API extension","title":"API extension","text":"The solver handles hole and face (plane) features that are either IsPrimitive or IsFreeForm. A few basic types are defined like SimpleHole and MeshHole, but new ones can be also defined. For example for point clouds, that don't have faces, like a mesh, only points.","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"This capability is properly documented, as a major API rewrite is going on in #3.","category":"page"},{"location":"api/#Defining-a-new-geometry","page":"API extension","title":"Defining a new geometry","text":"","category":"section"},{"location":"api/","page":"API extension","title":"API extension","text":"Defining a new geometry is pretty easy:","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"It has to be the subtype of either AbstractHoleGeometry or AbstractPlaneGeometry.\nThe GeometryStyle trait is need to be defined: it is either a IsPrimitive or IsFreeForm geometry.\nIsFreeForm geometries need to define the surfacepoints and filteredsurfacepoints functions.\nIsPrimitive geometries need to define the featurepoint functions\nThose IsPrimitive geometries that are subtype of AbstractHoleGeometry also need to define the featureradius function\nFinally, for visualization purposes the visualizationgeometry function should be defined, that returns an object, that can be used with the Meshviz.viz() function.","category":"page"},{"location":"api/#An-example","page":"API extension","title":"An example","text":"","category":"section"},{"location":"api/","page":"API extension","title":"API extension","text":"Let's assume that we want to define a new holelike type: MyDisk, which has a featurepoint, a normal, and a radius.","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"using BlankLocalizationCore\n\nstruct MyDisk <: AbstractHoleGeometry\n    point::Vector{Float64}\n    normal::Vector{Float64}\n    diameter::Float64\nend\n\nGeometryStyle(::Type{MyDisk}) = IsPrimitive()","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"It is an IsPrimitive and holelike feature, therefore we need to define the:","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"featurepoint\nfeatureradius\nvisualizationgeometry","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"functions. These look like as follows:","category":"page"},{"location":"api/","page":"API extension","title":"API extension","text":"featurepoint(::IsPrimitive, x::MyDisk) = x.point\nfeatureradius(::IsPrimitive, x::MyDisk) = x.diameter/2\n\nusing Meshes\n\nfunction visualizationgeometry(geom::MyDisk)\n    plane = Plane(Point3(geom.point), Vec3(geom.normal))\n    return Disk(plane, geom.diameter/2)\nend\n","category":"page"},{"location":"reference/#Reference-for-exported-types-and-functions","page":"Reference","title":"Reference for exported types and functions","text":"","category":"section"},{"location":"reference/#API-docstrings","page":"Reference","title":"API docstrings","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"These types and functions are the exported API by this package.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [BlankLocalizationCore]\nPrivate = false","category":"page"},{"location":"reference/#BlankLocalizationCore.AbstractHoleGeometry","page":"Reference","title":"BlankLocalizationCore.AbstractHoleGeometry","text":"Supertype of hole like localization geometries.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.AbstractPlaneGeometry","page":"Reference","title":"BlankLocalizationCore.AbstractPlaneGeometry","text":"Supertype of plane like geometries.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.FeatureDescriptor","page":"Reference","title":"BlankLocalizationCore.FeatureDescriptor","text":"Store description of a feature: its name, the corresponding part zero, if it has or has not a machined and a rough state.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.GeometryStyle","page":"Reference","title":"BlankLocalizationCore.GeometryStyle","text":"GeometryStyle\n\nTrait that describes the \"style\" of an AbstractLocalizationGeometry. Currently it can be either IsPrimitive or IsFreeForm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.HoleAndNormal","page":"Reference","title":"BlankLocalizationCore.HoleAndNormal","text":"HoleAndNormal <: AbstractHoleGeometry\n\nA hole structure with center point, axis and radius.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.HoleLocalizationFeature","page":"Reference","title":"BlankLocalizationCore.HoleLocalizationFeature","text":"HoleLocalizationFeature(descriptor::FeatureDescriptor, rough::R, machined::M) where {R<:AbstractHoleGeometry,M<:AbstractHoleGeometry}\n\nA holelike localization feature. The rough and machined geometries don't necessarily have to be the same type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.IsFreeForm","page":"Reference","title":"BlankLocalizationCore.IsFreeForm","text":"Free form geometries are discrete representations, e.g. a mesh or a point cloud.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.IsPrimitive","page":"Reference","title":"BlankLocalizationCore.IsPrimitive","text":"Primitive geometries can be explicitly described, e.g. a box or sphere.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.LocalizationFeature","page":"Reference","title":"BlankLocalizationCore.LocalizationFeature","text":"LocalizationFeature{R,M}\n\nSupertype of any localization features. A localization feature contains a feature descriptor (FeatureDescriptor) and a rough and machined geometry (AbstractLocalizationGeometry). The two geometries must be of same type (hole, plane, etc.). If a feature doesn't have a rough of machined state, an empty object should be used (and the feature descriptor should also store this information). based on its rough geometry.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.MeshHole","page":"Reference","title":"BlankLocalizationCore.MeshHole","text":"MeshHole <: AbstractHoleGeometry\n\nA simple mesh hole geometry, that contains the mesh of the hole's surface and the convex hull of the points (see our paper for details).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.MeshPlane","page":"Reference","title":"BlankLocalizationCore.MeshPlane","text":"MeshPlane <: AbstractPlaneGeometry\n\nA simple mesh plane geometry, that contains the mesh of a planar face.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.MultiOperationProblem","page":"Reference","title":"BlankLocalizationCore.MultiOperationProblem","text":"MultiOperationProblem\n\nCollect all data for a multi operation problem, including: part zeros, holes, planes, tolerances, parameters and optimization result.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.MultiOperationProblem-NTuple{5, Any}","page":"Reference","title":"BlankLocalizationCore.MultiOperationProblem","text":"MultiOperationProblem(partzeros, holes, planes, tolerances, parameters)\n\nConstruct a multi operation problem. For usage, please see the example section in the documentation. The parameters for the optimization are also described there with greater details.\n\nArguments\n\npartzeros::Vector{PartZero}: array of part zeros.\nholes::Vector{HoleLocalizationFeature}: array of holes.\nplanes::Vector{PlaneLocalizationFeature}: array of planes.\ntolerances::Vector{Tolerance}: array of tolerances.\nparameters::Dict{String,Any}: parameters in the form of a dictionary. Keys include:   minAllowance, OptimizeForToleranceCenter, UseTolerances,   SetPartZeroPosition, maxPlaneZAllowance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.OptimizationResult","page":"Reference","title":"BlankLocalizationCore.OptimizationResult","text":"OptimizationResult\n\nStore the status (result) of an optimization run and the minimum allowance value.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.PartZero","page":"Reference","title":"BlankLocalizationCore.PartZero","text":"PartZero(name, position, rotationmatrix)\n\nDefine a part zero with name, position and rotationmatrix relative to the workpiece datum.\n\nExample\n\njulia> PartZero(\"front\", [0,0,0], hcat([0,1,0], [0,0,1], [1,0,0]))\nPart zero: \"front\"\n[0.0 0.0 1.0 0.0; 1.0 0.0 0.0 0.0; 0.0 1.0 0.0 0.0; 0.0 0.0 0.0 1.0]\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.PlaneAndNormal","page":"Reference","title":"BlankLocalizationCore.PlaneAndNormal","text":"PlaneAndNormal <: AbstractPlaneGeometry\n\nA simple plane structure with one point and a normal vector.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.PlaneLocalizationFeature","page":"Reference","title":"BlankLocalizationCore.PlaneLocalizationFeature","text":"PlaneLocalizationFeature(descriptor::FeatureDescriptor, rough::R, machined::M) where {R<:AbstractPlaneGeometry,M<:AbstractPlaneGeometry}\n\nA planelike localization feature. The rough and machined geometries don't necessarily have to be the same type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.SimpleHole","page":"Reference","title":"BlankLocalizationCore.SimpleHole","text":"SimpleHole <: AbstractHoleGeometry\n\nA simple \"hole\" structure with a center point and a radius. Axis of the hole is defined by its partzero taken from the feature descriptor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.SimplePlane","page":"Reference","title":"BlankLocalizationCore.SimplePlane","text":"SimplePlane <: AbstractPlaneGeometry\n\nA simple plane structure with one point. Normal vector of the plane is defined by its partzero taken from the feature descriptor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.allowancetable-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.allowancetable","text":"allowancetable(mop::MultiOperationProblem)\n\nGenerate the allowance table for a given mop to examine the allowance for each feature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.featurepoint","page":"Reference","title":"BlankLocalizationCore.featurepoint","text":"featurepoint()\n\nReturn the feature point of an IsPrimitive geometry. Definition signature should look like: featurepoint(::IsPrimitive, x).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BlankLocalizationCore.featureradius","page":"Reference","title":"BlankLocalizationCore.featureradius","text":"featureradius()\n\nReturn the radius of a IsPrimitive geometry that is subtype of [AbstractHoleGeometry]. There is a default implementation that can be used: featureradius(::IsPrimitive, x) = x.r.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BlankLocalizationCore.filteredsurfacepoints","page":"Reference","title":"BlankLocalizationCore.filteredsurfacepoints","text":"filteredsurfacepoints()\n\nReturn the filtered points of the surface of an IsFreeForm geometry,  that may define active constraints in the optimization task (for example convex hull of mesh). Definition signature should look like: filteredsurfacepoints(::IsFreeForm, x).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BlankLocalizationCore.genmachinedholes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.genmachinedholes","text":"genmachinedholes(mop::MultiOperationProblem)\n\nGenerate Meshes object for each machined hole.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.genmachinedplanes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.genmachinedplanes","text":"genroughplanes(mop::MultiOperationProblem)\n\nGenerate Meshes object for each machined plane.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.genroughholes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.genroughholes","text":"genroughholes(mop::MultiOperationProblem)\n\nGenerate Meshes object for each rough hole.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.genroughplanes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.genroughplanes","text":"genroughplanes(mop::MultiOperationProblem)\n\nGenerate Meshes object for each rough plane.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.isoptimum-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.isoptimum","text":"isoptimum(mop::MultiOperationProblem)\n\nTell if mop's solution is in an optimal state, either: OPTIMAL or LOCALLY_SOLVED.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.isoptimum-Tuple{OptimizationResult}","page":"Reference","title":"BlankLocalizationCore.isoptimum","text":"isoptimum(or::OptimizationResult)\n\nTell if or is in an optimal solution state, either: OPTIMAL or LOCALLY_SOLVED.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.localizationfeature-Tuple{Any, AbstractHoleGeometry, AbstractHoleGeometry}","page":"Reference","title":"BlankLocalizationCore.localizationfeature","text":"localizationfeature(descriptor::FeatureDescriptor, rough::AbstractHoleGeometry, machined::AbstractHoleGeometry)\n\nConvenience constructor for HoleLocalizationFeature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.localizationfeature-Tuple{Any, AbstractPlaneGeometry, AbstractPlaneGeometry}","page":"Reference","title":"BlankLocalizationCore.localizationfeature","text":"localizationfeature(descriptor::FeatureDescriptor, rough::AbstractPlaneGeometry, machined::AbstractPlaneGeometry)\n\nConvenience constructor for PlaneLocalizationFeature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.minimumallowance-Tuple{Any}","page":"Reference","title":"BlankLocalizationCore.minimumallowance","text":"minimumallowance(allowancedb)\n\nCalculate the minimum allowances (radial and axial) for the given allowance database (computed by allowancetable).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.minimumallowance-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.minimumallowance","text":"minimumallowance(mop::MultiOperationProblem)\n\nCalculate the minimum allowances (radial and axial) for the given mop. Calls allowancetable under the hood.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.printpartzeropositions-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.printpartzeropositions","text":"printpartzeropositions(mop::MultiOperationProblem)\n\nPrint the positions of the part zeros of a MultiOperationProblem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.printpartzeropositions-Tuple{Vector{PartZero}}","page":"Reference","title":"BlankLocalizationCore.printpartzeropositions","text":"printpartzeropositions(partzeros::Vector{PartZero})\n\nPrint the positions of an array of part zeros.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.setparameters!-Tuple{MultiOperationProblem, Any}","page":"Reference","title":"BlankLocalizationCore.setparameters!","text":"setparameters!(mop::MultiOperationProblem, pardict)\n\nSet parameter dictionary of a MultiOperationProblem to pardict.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.surfacepoints","page":"Reference","title":"BlankLocalizationCore.surfacepoints","text":"surfacepoints()\n\nReturn the points of the surface of an IsFreeForm geometry. Definition signature should look like: surfacepoints(::IsFreeForm, x).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BlankLocalizationCore.toleranceerror-Tuple{Any}","page":"Reference","title":"BlankLocalizationCore.toleranceerror","text":"toleranceerror(tolerancedb)\n\nCalculate the average relative tolerance error for the given tolerance database (computed by tolerancetable). Gives the result in the 0-100 % range.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.toleranceerror-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.toleranceerror","text":"toleranceerror(mop::MultiOperationProblem)\n\nCalculate the average relative tolerance error for the given mop. Calls tolerancetable under the hood. Gives the result in the 0-100 % range.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.tolerancetable-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.tolerancetable","text":"tolerancetable(mop::MultiOperationProblem)\n\nGenerate the tolerance table for a given mop to examine the tolerances.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.visualizationgeometry","page":"Reference","title":"BlankLocalizationCore.visualizationgeometry","text":"visualizationgeometry(geom::AbstractLocalizationGeometry)\n\nReturn a Meshes.jl object that can be visualized.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Private-functions","page":"Reference","title":"Private functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"These functions and types are not exported, though they can be used if needed.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [BlankLocalizationCore]\nPublic = false","category":"page"},{"location":"reference/#BlankLocalizationCore.FON","page":"Reference","title":"BlankLocalizationCore.FON","text":"Union type for Float64 and Nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.NOTHING3","page":"Reference","title":"BlankLocalizationCore.NOTHING3","text":"A 3 long vector of nothings.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#BlankLocalizationCore.AbstractLocalizationGeometry","page":"Reference","title":"BlankLocalizationCore.AbstractLocalizationGeometry","text":"Supertype for localization geometries.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlankLocalizationCore.HV-Tuple{Any}","page":"Reference","title":"BlankLocalizationCore.HV","text":"Create a homogeneous vector by appending 1 to the end of a vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.collectallowancedholes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.collectallowancedholes","text":"collectallowancedholes(mop::MultiOperationProblem)\n\nCollect holes that have machined and rough states, thus allowance should be calculated for.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.collectallowancedplanes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.collectallowancedplanes","text":"collectallowancedplanes(mop::MultiOperationProblem)\n\nCollect planes that have machined and rough states, thus allowance should be calculated for.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.collectmachinedholes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.collectmachinedholes","text":"collectmachinedholes(mop::MultiOperationProblem)\n\nCollect holes that have a machined state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.collectmachinedplanes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.collectmachinedplanes","text":"collectmachinedplanes(mop::MultiOperationProblem)\n\nCollect planes that have a machined state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.collectroughholes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.collectroughholes","text":"collectroughholes(mop::MultiOperationProblem)\n\nCollect those holes, that have rough stage.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.collectroughplanes-Tuple{MultiOperationProblem}","page":"Reference","title":"BlankLocalizationCore.collectroughplanes","text":"collectroughplanes(mop::MultiOperationProblem)\n\nCollect those planes, that have rough stage.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.getfeaturebyname-Tuple{MultiOperationProblem, Any}","page":"Reference","title":"BlankLocalizationCore.getfeaturebyname","text":"getfeaturebyname(mop::MultiOperationProblem, featurename)\n\nGet a hole or plane feature by its name. It is assumed that all features have distinct names. Return nothing, if no feature is found with featurename.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.getholesbypartzero-Tuple{MultiOperationProblem, Any}","page":"Reference","title":"BlankLocalizationCore.getholesbypartzero","text":"collectholesbypartzero(mop::MultiOperationProblem, partzeroname)\n\nCollect holes that are grouped to part zero called partzeroname.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.getpartzeroHM-Tuple{PartZero}","page":"Reference","title":"BlankLocalizationCore.getpartzeroHM","text":"getpartzeroHM(partzero::PartZero)\n\nGet homogeneous matrix of part zero partzero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.getpartzerobyname-Tuple{Vector{PartZero}, AbstractString}","page":"Reference","title":"BlankLocalizationCore.getpartzerobyname","text":"getpartzerobyname(partzeros::Vector{PartZero}, partzeroname::AbstractString)\n\nReturn the first part zero from partzeros, thats name is partzeroname.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.getpartzeroinverseHM-Tuple{PartZero}","page":"Reference","title":"BlankLocalizationCore.getpartzeroinverseHM","text":"getpartzeroinverseHM(partzero::PartZero)\n\nGet the inverse homogeneous matrix of part zero partzero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.inverthomtr-Tuple{Any}","page":"Reference","title":"BlankLocalizationCore.inverthomtr","text":"inverthomtr(M)\n\nInvert a homogeneous transformation matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlankLocalizationCore.transformmachinedgeoms-Tuple{LocalizationFeature}","page":"Reference","title":"BlankLocalizationCore.transformmachinedgeoms","text":"transformmachinedgeoms(lf::LocalizationFeature)\n\nGet the rough state of lf and transform it according to its current part zero transformation.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlankLocalizationCore","category":"page"},{"location":"#BlankLocalizationCore","page":"Home","title":"BlankLocalizationCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This repository contains the reference implentation for the multi operation blank localization technique described in our paper Multi-operation optimal blank localization for near net shape machining. The paper is available is here: https://www.sciencedirect.com/science/article/pii/S0007850623000884.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{cserteg:2023_MultioperationOptimalBlank,\n  title = {Multi-Operation Optimal Blank Localization for near Net Shape Machining},\n  author = {Cserteg, Tamás and Kovács, András and Váncza, József},\n  year = {2023},\n  month = jun,\n  journal = {CIRP Annals},\n  issn = {0007-8506},\n  doi = {10.1016/j.cirp.2023.04.049},\n}","category":"page"},{"location":"#Blank-localization-briefly","page":"Home","title":"Blank localization briefly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of multi operation blank localization is to align the CNC machining code for the rough (e.g. cast, 3D printed, etc.) parts. When doing so, one must consider two important factors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"leaving enough material to be removed by the tool (machining allowance)\nrespecting the dimensional tolerances between features (defined on the part drawing)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our paper proposes a method, that ensures a proper machining allowance (minimum requirement), while trying to optimize to the center of the tolerance fields between features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation goes through a detailed example of the process while showing how to use the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is registered in the general registry, so it can be installed via running:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add BlankLocalizationCore","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the exaplanation on how the package works, please read through the Example page.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package couldn't have been created without the great people behind the following projects (as well as the whole Julia ecosystem):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Meshes.jl, MeshViz.jl and the Makie.jl ecosystem\nJuMP.jl\nDataFrames.jl and PrettyTables.jl","category":"page"},{"location":"#Related-literature","page":"Home","title":"Related literature","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our work has been published in several papers, one of them is still in print. The list (in chronological order):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Digital twin assisted workpiece referencing for compensating the stock deviation of casted parts: link to paper\nMulti-operation optimal blank localization for near net shape machining: link to paper\nMulti-operation blank localization with hybrid point cloud and feature-based representation: link to pre-print paper","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"This example can be found as a single file in the repository under the examples folder. The script file does not contain the package installation steps, though it comes with a Project.toml file that you can instantiate.","category":"page"},{"location":"example/#Getting-started","page":"Example","title":"Getting started","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Install the necessary packages:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Ipopt (or Xpress)\nMeshes and GLMakie: only necessary for visualization","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"] add BlankLocalizationCore Ipopt Meshes GLMakie","category":"page"},{"location":"example/#Example-part","page":"Example","title":"Example part","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The following part is crafted for demonstrating purposes. The CAD files are available here: machined and rough. The two images below show the part from its \"front\" and \"back\" sides in its machined state.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: Machined look front)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: Machined look back)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"All six holes needs to be machined and also their front faces, which means that there are six machined planes.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The part in its rough (to be machined) state is shown below:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: Rough look front)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: Rough look back)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The rough part is also designed in CAD, of course in production the dimensions of the rough part come from a measurement process. It can be seen, that the holes on the rough part are smaller, and their axes' are also modified a little bit in a few cases to showcase the possibilities of the algorithm.","category":"page"},{"location":"example/#Part-zeros","page":"Example","title":"Part zeros","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"There are three part zeros, their attributes are listed in the table below. Their axes' are shown relative to the workpiece datum.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Part zero name x axis y axis z axis\nfront y z x\nright -x z y\nback -y z -x","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"They can be defined in julia like this.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using BlankLocalizationCore\n\n## Part zero definitions\n\npzf = PartZero(\"front\", [0,0,0], hcat([0,1,0], [0,0,1], [1,0,0]))\npzr = PartZero(\"right\", [0,0,0], hcat([-1, 0, 0], [0, 0, 1], [0, 1, 0]))\npzb = PartZero(\"back\", [0,0,0], hcat([0, -1, 0], [0, 0, 1], [-1, 0, 0]))\n\npartzeros = [pzf, pzr, pzb]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"When constructing a part zero, a default [0,0,0] position is set, as the goal of the optimization process is to find the values of those position. For more details see the docs of PartZero.","category":"page"},{"location":"example/#Machined-features","page":"Example","title":"Machined features","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The following are the features' positions (six holes and six faces):","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Name Part zero name Position (relative to part zero) Radius (if hole)\nfront hole front [0, 0, 0] 29\nfront face front [0, 0, 0] \nright hole 1 right [16, 15, 0] 7.5\nright hole 2 right [25, -16, 3] 9\nright hole 3 right [60, 0, -3] 13.5\nright face 1 right [16, 15, 0] \nright face 2 right [25, -16, 3] \nright face 3 right [60, 0, -3] \nback hole 1 back [-14, 14, 0] 9\nback hole 2 back [14, 14, 0] 9\nback face 1 back [-14, 14, 0] \nback face 2 back [14, 14, 0] ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The machined geometries are represented with primitive features, and can be done this way:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"## Machined geometry definitions\n\nfronthole_m = SimpleHole([0, 0, 0], 29)\nfrontface_m = SimplePlane([0, 0, 0])\n\nrighthole1_m = SimpleHole([16, 15, 0], 7.5)\nrighthole2_m = SimpleHole([25, -16, 3], 9)\nrighthole3_m = SimpleHole([60, 0, -3], 13.5)\nrightface1_m = SimplePlane([16, 15, 0])\nrightface2_m = SimplePlane([25, -16, 3])\nrightface3_m = SimplePlane([60, 0, -3])\n\nbackhole1_m = SimpleHole([-14, 14, 0], 9)\nbackhole2_m = SimpleHole([14, 14, 0], 9)\nbackface1_m = SimplePlane([-14, 14, 0])\nbackface2_m = SimplePlane([14, 14, 0])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Holes are defined with their CNC machining position relative to their corresponding part zero, and their radius. Planes are defined with their position relative to their part zero. Orientation of the hole axes and plane normals are defined by their part zero (z axis).","category":"page"},{"location":"example/#Rough-features","page":"Example","title":"Rough features","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The rough features are measured relative to the workpiece datum and are listed below.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Name Position (relative to part zero) Radius (if hole)\nfront hole [82.5, 30, 40] 26\nfront face [82.5, 30, 40] \nright hole 1 [66, 71.5, 55] 6\nright hole 2 [58, 74.5, 24] 4.905\nright hole 3 [21.5, 68.5, 40] 16\nright face 1 [66, 71.5, 55] \nright face 2 [58, 74.5, 24] \nright face 3 [21.5, 68.5, 40] \nback hole 1 [-3, 44, 53.9] 6.2\nback hole 2 [-3, 16.1, 54] 6.25\nback face 1 [-3, 44, 54] \nback face 2 [-3, 16, 54] ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In julia we define primitive features just like before. Note that a plane normal is given, that is only used later when visualizing the planes.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"## Rough geometry definitions\n\nfronthole_r = HoleAndNormal([82.5, 30, 40], [1, 0, 0], 26)\nfrontface_r = PlaneAndNormal([82.5, 30, 40], [1, 0, 0])\n\nrighthole1_r = HoleAndNormal([66, 71.5, 55], [0, 1, 0], 6)\nrighthole2_r = HoleAndNormal([58, 74.5, 24], [0, 1, 0], 4.905)\nrighthole3_r = HoleAndNormal([21.5, 68.5, 40], [0, 1, 0], 8)\nrightface1_r = PlaneAndNormal([66, 71.5, 55], [0, 1, 0])\nrightface2_r = PlaneAndNormal([58, 74.5, 24], [0, 1, 0])\nrightface3_r = PlaneAndNormal([21.5, 68.5, 40], [0, 1, 0])\n\nbackhole1_r = HoleAndNormal([-3, 44, 53.9], [-1, 0, 0], 6.2)\nbackhole2_r = HoleAndNormal([-3, 16.1, 54], [-1, 0, 0], 6.25)\nbackface1_r = PlaneAndNormal([-3, 44, 54], [-1, 0, 0])\nbackface2_r = PlaneAndNormal([-3, 16, 54], [-1, 0, 0])","category":"page"},{"location":"example/#Pairing-the-rough-and-machined-features","page":"Example","title":"Pairing the rough and machined features","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"To create LocalizationFeatures, that will be subject to the optimizatio, a FeatureDescriptor is needed to be defined for each. This \"joins\" a rough and machined geometry, and contains information such as the name and part zero of the feature and if a feature has a machined and rough state. (There are cases, when this can be important, for this example all features have machined and rough state).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This will look like this in julia:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"## Geometry pairing and feature descriptors\n\n# Feature descriptors for each feature\n\nfd_fronthole = FeatureDescriptor(\"fronthole\", pzf, true, true)\nfd_frontface = FeatureDescriptor(\"frontface\", pzf, true, true)\n\nfd_righthole1 = FeatureDescriptor(\"righthole1\", pzr, true, true)\nfd_righthole2 = FeatureDescriptor(\"righthole2\", pzr, true, true)\nfd_righthole3 = FeatureDescriptor(\"righthole3\", pzr, true, true)\nfd_rightface1 = FeatureDescriptor(\"rightface1\", pzr, true, true)\nfd_rightface2 = FeatureDescriptor(\"rightface2\", pzr, true, true)\nfd_rightface3 = FeatureDescriptor(\"rightface3\", pzr, true, true)\n\nfd_backhole1 = FeatureDescriptor(\"backhole1\", pzb, true, true)\nfd_backhole2 = FeatureDescriptor(\"backhole2\", pzb, true, true)\nfd_backface1 = FeatureDescriptor(\"backface1\", pzb, true, true)\nfd_backface2 = FeatureDescriptor(\"backface2\", pzb, true, true)\n\n# Hole features\n\nholes = [HoleLocalizationFeature(fd_fronthole, fronthole_r, fronthole_m),\n    HoleLocalizationFeature(fd_righthole1, righthole1_r, righthole1_m),\n    HoleLocalizationFeature(fd_righthole2, righthole2_r, righthole2_m),\n    HoleLocalizationFeature(fd_righthole3, righthole3_r, righthole3_m),\n    HoleLocalizationFeature(fd_backhole1, backhole1_r, backhole1_m),\n    HoleLocalizationFeature(fd_backhole2, backhole2_r, backhole2_m)\n    ]\n\n# Face features\nplanes = [PlaneLocalizationFeature(fd_frontface, frontface_r, frontface_m),\nPlaneLocalizationFeature(fd_rightface1, rightface1_r, rightface1_m),\nPlaneLocalizationFeature(fd_rightface2, rightface2_r, rightface2_m),\nPlaneLocalizationFeature(fd_rightface3, rightface3_r, rightface3_m),\nPlaneLocalizationFeature(fd_backface1, backface1_r, backface1_m),\nPlaneLocalizationFeature(fd_backface2, backface2_r, backface2_m)\n]","category":"page"},{"location":"example/#Tolerances","page":"Example","title":"Tolerances","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"A tolerance is described between two feature (their feature point to be precise), and their distance is calculated with a certain projection (usually projection to one of the axis of the workpiece datum, but any R^3->R transformation can be used). This projected distance must be between the lower and upper values of the tolerance. Tolerance can be defined between both rough and/or machined features.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For this example, the tolerances are created based on the drawing of the machined part. This is the drawing, which only contains dimensions related to the optimization problem. It is also available as a pdf here.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: Tolerances)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Axes in the \"Pojection\" column mean the axes of the workpiece datum. The distance of the two features' feature points are projected to those axes.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"{#} F1 name F1: machined/rough Projection F2 name F2: machined/rough Nominal value Lower value Upper value\n1 right face 1 machined y axis front hole machined 41 40.7 41.3\n2 back hole 1 machined y axis front hole machined 14 13.8 14.2\n3 front hole machined y axis back hole 2 machined 14 13.8 14.2\n4 back hole 1 machined z axis front hole machined 14 13.8 14.2\n5 back hole 2 machined z axis front hole machined 14 13.8 14.2\n6 right face 3 machined y axis front hole machined 38 37.7 38.3\n7 right face 2 machined y axis front hole machined 44 43.7 44.3\n8 front face machined x axis right hole 3 machined 60 59.7 60.3\n9 front face machined x axis right hole 2 machined 25 24.8 25.2\n10 front face machined x axis right hole 1 machined 16 15.8 16.2\n11 right hole 1 machined z axis front hole machined 15 14.8 15.2\n12 front hole machined z axis right hole 2 machined 16 15.8 16.2\n13 front face machined x axis back face 1 rough 85 84.6 85.4\n14 front face machined x axis back face 2 rough 85 84.6 85.4\n15 right hole 3 machined z axis front hole machined 0 -0.2 0.2","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To express these tolerances in julia, the following code is used. The above table is changed with the followings:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Those feature names are used, that we defined in the FeatureDescriptors.\nWhere the machined state of a feature is used, a true used, and false for rough state.\nThree functions are defined that do the projection: xfunc, yfunc, zfunc. Those are passed to the struct constructor.\nThe julia struct also contains a note string, the numbering of the tolerances are given there for this example.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"## Tolerances\n\nxfunc(x) = x[1]\nyfunc(x) = x[2]\nzfunc(x) = x[3]\n\ntolerances = [Tolerance(\"rightface1\", true, yfunc, \"fronthole\", true, 41, 40.7, 41.3, \"1\"),\nTolerance(\"backhole1\", true, yfunc, \"fronthole\", true, 14, 13.8, 14.2, \"2\"),\nTolerance(\"fronthole\", true, yfunc, \"backhole2\", true, 14, 13.8, 14.2, \"3\"),\nTolerance(\"backhole1\", true, zfunc, \"fronthole\", true, 14, 13.8, 14.2, \"4\"),\nTolerance(\"backhole2\", true, zfunc, \"fronthole\", true, 14, 13.8, 14.2, \"5\"),\nTolerance(\"rightface3\", true, yfunc, \"fronthole\", true, 38, 37.7, 38.3, \"6\"),\nTolerance(\"rightface2\", true, yfunc, \"fronthole\", true, 44, 43.7, 44.3, \"7\"),\nTolerance(\"frontface\", true, xfunc, \"righthole3\", true, 60, 59.7, 60.3, \"8\"),\nTolerance(\"frontface\", true, xfunc, \"righthole2\", true, 25, 24.8, 25.2, \"9\"),\nTolerance(\"frontface\", true, xfunc, \"righthole1\", true, 16, 15.8, 16.2, \"10\"),\nTolerance(\"righthole1\", true, zfunc, \"fronthole\", true, 15, 14.8, 15.2, \"11\"),\nTolerance(\"fronthole\", true, zfunc, \"righthole2\", true, 16, 15.8, 16.2, \"12\"),\nTolerance(\"frontface\", true, xfunc, \"backface1\", false, 85, 84.6, 85.4, \"13\"),\nTolerance(\"frontface\", true, xfunc, \"backface2\", false, 85, 84.6, 85.4, \"14\"),\nTolerance(\"righthole3\", true, zfunc, \"fronthole\", true, 0, -0.2, 0.2, \"15\")]","category":"page"},{"location":"example/#Constructing-and-solving-the-optimization-problem","page":"Example","title":"Constructing and solving the optimization problem","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"A few parameters are needed for the optimization problem, passed to the object as a dictionary. These are:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Name (key) Description Suggested value Required?\nminAllowance Minimum allowance that must be achieved even by the lowest value. 0.1 Required\nOptimizeForToleranceCenter The default method is to optimize for the middle (center) of the tolerance fields. For debugging, one can set it to false, then the minimum allowance will be maximised (ignoring the minAllowance value). true Required\nUseTolerances Also a debugging feature. Tolerance lower-upper values are added as active constraints on the distance of the corresponding features. This can be turned off with this flag. true Required\nSetPartZeroPosition The position of each part zero can be set with this option. A vector of 3 long vectors is expected, that is matched with the number of part zeros. Empty vectors can be passed, if not all part zero positions should be set. For example setting this option to [[], [], []] for three part zeros will have no effect. NaN elements are ignored, which means that specific axes of part zeros can be set. For example [[NaN, 150, Nan], [], []] would only set the value of the Y axis of the first part zero, all others are unaffected.  Optional\nmaxPlaneZAllowance The allowance has no upper bound by default. For planes, it is possible to set an upper bound to avoid the issue of \"machining the whole part away\".  Optional","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"An optimization solver is needed for which we use Xpress.jl in our research. A license is required for FICO Xpress (though the generated problem size does not exceed the limit of the (free) community license). The Ipopt and SCIP solvers were also tested and can be used. We use the former in this example.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"## Constructing and solving the optimization problem\npard = Dict(\"minAllowance\"=>0.5, \"OptimizeForToleranceCenter\"=>true,\n    \"UseTolerances\"=>true, \"maxPlaneZAllowance\"=>1);\n\nmop = MultiOperationProblem(partzeros, holes, planes, tolerances, pard)\n\nimport Ipopt # or Xpress if you have a license\noptimizeproblem!(mop, Ipopt.Optimizer)\n\n#=\n# the following lines are condensed in the above one line: \nimport JuMP\nmop_model = createjumpmodel(mop, Xpress.Optimizer);\nJuMP.optimize!(mop_model)\nsetjumpresult!(mop, mop_model)\n=#","category":"page"},{"location":"example/#Evaluating-the-result","page":"Example","title":"Evaluating the result","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Two tables are available for analyzing the result: the allowance and tolerance tables. Copying them from the REPL looks like this:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> printallowancetable(mop)\n                                                      Allowance table Min allowance radial: 1.489 axial: 0.500\n┌────────────┬──────────────┬───────────┬───────────┬───────────┬────────┬────────┬────────┬───────────┬────────┬────────────┬───────────┬────────────┬─────────────┐\n│       name │ partzeroname │ machinedx │ machinedy │ machinedz │ roughx │ roughy │ roughz │ machinedr │ roughr │ xydistance │ zdistance │ rallowance │ axallowance │\n├────────────┼──────────────┼───────────┼───────────┼───────────┼────────┼────────┼────────┼───────────┼────────┼────────────┼───────────┼────────────┼─────────────┤\n│  fronthole │        front │      82.0 │   29.7558 │   39.9886 │   82.5 │   30.0 │   40.0 │      29.0 │   26.0 │    0.24448 │           │    2.75552 │             │\n│ righthole1 │        right │      66.0 │   70.7558 │   54.9886 │   66.0 │   71.5 │   55.0 │       7.5 │    6.0 │  0.0114074 │           │    1.48859 │             │\n│ righthole2 │        right │      57.0 │   73.7558 │   23.9886 │   58.0 │   74.5 │   24.0 │       9.0 │  4.905 │    1.00007 │           │    3.09493 │             │\n│ righthole3 │        right │      22.0 │   67.7558 │   39.9886 │   21.5 │   68.5 │   40.0 │      13.5 │    8.0 │    0.50013 │           │    4.99987 │             │\n│  backhole1 │         back │     -2.25 │   43.7558 │   53.9886 │   -3.0 │   44.0 │   53.9 │       9.0 │    6.2 │   0.259786 │           │    2.54021 │             │\n│  backhole2 │         back │     -2.25 │   15.7558 │   53.9886 │   -3.0 │   16.1 │   54.0 │       9.0 │   6.25 │   0.344403 │           │     2.4056 │             │\n│  frontface │        front │      82.0 │   29.7558 │   39.9886 │   82.5 │   30.0 │   40.0 │           │        │            │      -0.5 │            │         0.5 │\n│ rightface1 │        right │      66.0 │   70.7558 │   54.9886 │   66.0 │   71.5 │   55.0 │           │        │            │ -0.744214 │            │    0.744214 │\n│ rightface2 │        right │      57.0 │   73.7558 │   23.9886 │   58.0 │   74.5 │   24.0 │           │        │            │ -0.744214 │            │    0.744214 │\n│ rightface3 │        right │      22.0 │   67.7558 │   39.9886 │   21.5 │   68.5 │   40.0 │           │        │            │ -0.744214 │            │    0.744214 │\n│  backface1 │         back │     -2.25 │   43.7558 │   53.9886 │   -3.0 │   44.0 │   54.0 │           │        │            │     -0.75 │            │        0.75 │\n│  backface2 │         back │     -2.25 │   15.7558 │   53.9886 │   -3.0 │   16.0 │   54.0 │           │        │            │     -0.75 │            │        0.75 │\n└────────────┴──────────────┴───────────┴───────────┴───────────┴────────┴────────┴────────┴───────────┴────────┴────────────┴───────────┴────────────┴─────────────┘\n\njulia> printtolerancetable(mop)\n                                                     Tolerance table avgabsreltolerror: 0.0%\n┌───────┬──────────────┬───────────┬──────────────┬───────────┬──────────┬────────┬────────┬────────────────────────────┬───────┬────────────────┐\n│ Tol # │     feature1 │ partzero1 │     feature2 │ partzero2 │ nominald │ lowerd │ upperd │                   distance │ reald │ tolerancefield │\n├───────┼──────────────┼───────────┼──────────────┼───────────┼──────────┼────────┼────────┼────────────────────────────┼───────┼────────────────┤\n│     1 │ M rightface1 │     right │  M fronthole │     front │     41.0 │   40.7 │   41.3 │        [-16.0, 41.0, 15.0] │  41.0 │          0.0 % │\n│     2 │  M backhole1 │      back │  M fronthole │     front │     14.0 │   13.8 │   14.2 │       [-84.25, 14.0, 14.0] │  14.0 │         -0.0 % │\n│     3 │  M fronthole │     front │  M backhole2 │      back │     14.0 │   13.8 │   14.2 │       [84.25, 14.0, -14.0] │  14.0 │          0.0 % │\n│     4 │  M backhole1 │      back │  M fronthole │     front │     14.0 │   13.8 │   14.2 │       [-84.25, 14.0, 14.0] │  14.0 │          0.0 % │\n│     5 │  M backhole2 │      back │  M fronthole │     front │     14.0 │   13.8 │   14.2 │      [-84.25, -14.0, 14.0] │  14.0 │          0.0 % │\n│     6 │ M rightface3 │     right │  M fronthole │     front │     38.0 │   37.7 │   38.3 │         [-60.0, 38.0, 0.0] │  38.0 │          0.0 % │\n│     7 │ M rightface2 │     right │  M fronthole │     front │     44.0 │   43.7 │   44.3 │       [-25.0, 44.0, -16.0] │  44.0 │          0.0 % │\n│     8 │  M frontface │     front │ M righthole3 │     right │     60.0 │   59.7 │   60.3 │         [60.0, -38.0, 0.0] │  60.0 │          0.0 % │\n│     9 │  M frontface │     front │ M righthole2 │     right │     25.0 │   24.8 │   25.2 │        [25.0, -44.0, 16.0] │  25.0 │          0.0 % │\n│    10 │  M frontface │     front │ M righthole1 │     right │     16.0 │   15.8 │   16.2 │       [16.0, -41.0, -15.0] │  16.0 │          0.0 % │\n│    11 │ M righthole1 │     right │  M fronthole │     front │     15.0 │   14.8 │   15.2 │        [-16.0, 41.0, 15.0] │  15.0 │          0.0 % │\n│    12 │  M fronthole │     front │ M righthole2 │     right │     16.0 │   15.8 │   16.2 │        [25.0, -44.0, 16.0] │  16.0 │          0.0 % │\n│    13 │  M frontface │     front │  R backface1 │      back │     85.0 │   84.6 │   85.4 │ [85.0, -14.2442, -14.0114] │  85.0 │         -0.0 % │\n│    14 │  M frontface │     front │  R backface2 │      back │     85.0 │   84.6 │   85.4 │  [85.0, 13.7558, -14.0114] │  85.0 │         -0.0 % │\n│    15 │ M righthole3 │     right │  M fronthole │     front │      0.0 │   -0.2 │    0.2 │         [-60.0, 38.0, 0.0] │   0.0 │          0.0 % │\n└───────┴──────────────┴───────────┴──────────────┴───────────┴──────────┴────────┴────────┴────────────────────────────┴───────┴────────────────┘","category":"page"},{"location":"example/#Visualizing-the-result","page":"Example","title":"Visualizing the result","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"For visualization the Meshes and Makie ecosystems are used. The idea is to \"convert\" the BlankLocalizationCore objects to Meshes objects, that can be then visualized with the Meshes-Makie package extension. After loading Makie and Meshes, the viz and viz! functions should be available.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"I wrote a small function that creates a Makie.FigureAxisPlot, which we can then use to plot into. Not that sophisticated I know.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"import GLMakie\n\nusing Meshes\n\nfunction initviz(;hideaxes=false)\n    f = viz([Point(i, j, k) for i in 0:1 for j in 0:1 for k in 0:1], size=0.01, color=:white)\n    if hideaxes\n        f.axis.show_axis[] = false\n    end\n    f\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Then, the with the following functions we can generate Meshes objects, then visualize them with the viz or viz! functions.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"rholes = genroughholes(mop)\nmholes = genmachinedholes(mop)\nmplanes = genmachinedplanes(mop)\nrplanes = genroughplanes(mop)\n\nf = initviz(hideaxes=false)\nviz!.(rholes, alpha=0.5, color=:red)\nviz!.(mholes, alpha=0.5, color=:blue)\nviz!.(rplanes, alpha=0.5, color=:red)\nviz!.(mplanes, alpha=0.5, color=:blue)\n#GLMakie.save(\"example-part.png\", f)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: Visualization)","category":"page"}]
}
